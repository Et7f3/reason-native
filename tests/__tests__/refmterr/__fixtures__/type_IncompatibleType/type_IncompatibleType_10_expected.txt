[27m[24m[2m[1m# Unformatted Error Output:[27m[24m[22m
[2m# [22m[2mFile "tests/__tests__/refmterr/__fixtures__/type_IncompatibleType/type_IncompatibleType_10.ml", line 8, characters 27-28:[22m
[2m# [22m[2mError: This expression has type $Cons_'b hlist[22m
[2m# [22m[2m       but an expression was expected of type 'a[22m
[2m# [22m[2m       The type constructor $Cons_'b would escape its scope[22m


[7m[24m[22m[1m[31m ERROR [27m[24m[22m[39m [27m[4m[22m[36mtests/__tests__/refmterr/__fixtures__/type_IncompatibleType/type_IncompatibleType_10.ml[27m[24m[22m[39m[27m[4m[22m[2m:8 27-28[27m[24m[22m 

[2m5 â”† [22m
[2m6 â”† [22m[27m[24m[22m[2m[35mlet[27m[24m[22m[39m[27m[24m[22m[2m rec len ([27m[24m[22m[27m[24m[22m[2m[35mtype[27m[24m[22m[39m[27m[24m[22m[2m a) (l: a hlist): [27m[24m[22m[27m[24m[22m[2m[33mint[27m[24m[22m[39m[27m[24m[22m[2m = match l with[27m[24m[22m
[2m7 â”† [22m[27m[24m[22m[2m  | [27m[24m[22m[27m[24m[22m[2m[34mNil[27m[24m[22m[39m[27m[24m[22m[2m -> [27m[24m[22m[27m[24m[22m[2m[34m0[27m[24m[22m[39m
[27m[24m[22m[2m[31m8 â”† [27m[24m[22m[39m[27m[24m[22m[2m  | [27m[24m[22m[27m[24m[22m[2m[34mCons[27m[24m[22m[39m[27m[24m[22m[2m (h, t) -> [27m[24m[22m[27m[24m[22m[2m[34m1[27m[24m[22m[39m[27m[24m[22m[2m[31m + [27m[24m[22m[39m[27m[24m[22m[2mlen [27m[24m[22m[27m[4m[22m[1m[31mt[27m[24m[22m[39m


[1mThis allows type [22m[27m[4m[22m[1m[31mthereExistsAType_Cons_'b[27m[24m[22m[39m[1m to "escape" its scope.[22m


  This type: [27m[24m[22m[1m[31mhlist(thereExistsAType_Cons_'b)[27m[24m[22m[39m
  Expecting: [27m[24m[22m[1m[32m'a[27m[24m[22m[39m

[27m[24m[22m[1m[35mLearn:[27m[24m[22m[39m[27m[24m[2m[1m What does it mean for a type variable to "escape" its scope?[27m[24m[22m
[2mImportant assumptions about the type are potentially being violated because
values of that type are being passed outside the region ("escaping").
The error you see is likely preventing a runtime error.

These types that aren't allowed to escape are introduced when using GADTs or
locally abstract types (when you see functions defined in these forms):

  let myFunction : type a . a => a = ...
  let myFunction = (type a, x: a) => ...

If the names of these types are weird, then they're probably not ones defined
in locally abstract types, but generated by type inference when using GADTs

Some things that might solve the problem:
- Avoid passing these values outside this local region
- Wrap the value in a GADT making the escaping type "existential".
- Annotate the function it escapes to with locally abstract to match your function.
- Make sure locally abstract type annotations are polymorphic. They aren't by default.[22m


